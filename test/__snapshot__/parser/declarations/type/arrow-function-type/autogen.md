# Kataw parser test case

> Arrow function type
>

## Input

### Cases

> `````js
> ((q, x)=> T) => T
> `````

> `````js
> ((q,)=> T) => T
> `````

> `````js
> ((q, | x )=> T) => T
> `````

> `````js
> ((| q, | x )=> T) => T
> `````

> `````js
> (( x )=> T) => T
> `````

> `````js
> (( x )) => T
> `````

> `````js
> (( x[] )) => T
> `````

> `````js
> (( x[][][] )) => T
> `````

> `````js
> (( x[][][x=> T] )) => T
> `````

> `````js
> (( x[][][x=> T] ) | x) => T
> `````

> `````js
> (( x[][][x=> T] ) | x & {a:b}) => T
> `````

> `````js
> (( x[][][x=> T] ) | x & {a:() => T}) => T
> `````

> `````js
> (( x[][][x=> T] ) | x & {(): string => T}) => T
> `````

> `````js
> (( x[][][x=> T] )  & {(): string => T}) => T
> `````

> `````js
> (( x[][x=> T] )  & {(): string => T}) => T
> `````

> `````js
> (( [x=> T] )  & {(): string => T}) => T
> `````

> `````js
> ({(): string => T}) => T
> `````

> `````js
> ({(): string => T},) => T
> `````

> `````js
> ({[x]: string => T},) => T
> `````

> `````js
> (&x,) => T
> `````

> `````js
> (&x,|a) => T
> `````

> `````js
> (&x,|a&c) => T
> `````

> `````js
> (&x,|a&c,) => T
> `````

> `````js
> (&x,|a&c,symbol['string']) => T
> `````

> `````js
> (&1,|2&3,symbol['string']) => T
> `````

> `````js
> (&1) => T
> `````

> `````js
> (&1,) => T
> `````

> `````js
> (|2 |1) => T
> `````

> `````js
> (|2 |1) => 3&4
> `````

> `````js
> ((|2 |1) => 3&4) => 5&6
> `````

> `````js
> ((|2 |1,) => 3&4) => 5&6
> `````

> `````js
> (() => 3&4) => 5&6
> `````

> `````js
> ((x,) => 3&4) => 5&6
> `````

> `````js
> (() => (3&4)) => 5&6
> `````

> `````js
> (() => (3&4)) => 5&6
> `````

> `````js
> (x) => 5&6
> `````

> `````js
> (((((b) => c) => c) => c) => c) => c
> `````

> `````js
> (((((b) => c | x) => c) => c) => c) => c
> `````

> `````js
> (((((...b) => c | x) => c) => c) => c) => c
> `````

> `````js
> (...((((...b) => c | x) => c) => c) => c) => c
> `````

> `````js
> (...(...(((...b) => c | x) => c) => c) => c) => c
> `````

> `````js
> (...(...(...(...(...b) => c | x) => c) => c) => c) => c
> `````

> `````js
> (...b) => c
> `````

> `````js
> (...b | d) => c
> `````

> `````js
> (| b | d) => c
> `````

> `````js
> (...b[] | d) => c
> `````

> `````js
> (...b[()=> c] | d) => c
> `````

> `````js
> (...b[(x)=> c] | d) => c
> `````

> `````js
> (...b[(number)=> c] | d) => c
> `````

> `````js
> (...b[(number[])=> c] | d) => c
> `````

> `````js
> (...b[([number | string])=> c] | d) => c
> `````

> `````js
> (...b[([?number | string])=> c] | d) => c
> `````

> `````js
> (...?b[([?number | string])=> c] | d) => c
> `````

> `````js
> (...b[?([?number | string])=> c] | d) => c
> `````

> `````js
> (...b?:string | d) => c
> `````

> `````js
> (d:void) => c
> `````

> `````js
> () => c|d
> `````

> `````js
> (() => c|d) => c|d
> `````

> `````js
> ([() => c|d]) => c|d
> `````

> `````js
> (...[() => c|d]) => c|d
> `````

> `````js
> (|x,...[() => c|d]) => c|d
> `````

> `````js
> (|x,...[() => c[]|d]) => c|d
> `````

> `````js
> (|x,...[() => c[|a|b]|d]) => c|d
> `````

> `````js
> (|x,...[() => c[|a|b]|d]&(|x,...[() => c[|a|b]|d]) => c|d) => c|d
> `````

> `````js
> ((|x,...[() => c[|a|b]|d]&(|x,...[() => c[|a|b]|d]) => c|d) => c|d)
> `````

> `````js
> (-1) => [c|d]
> `````

> `````js
> ({}) => [c|d]
> `````

> `````js
> ({key:value}) => [c|d]
> `````

> `````js
> ({key:string | number}) => [c|d]
> `````

> `````js
> ({key:string | number}) => [c|d]
> `````

> `````js
> ({key?:string | number}) => [c|d]
> `````

> `````js
> (?{key?:string | number}) => [c|d]
> `````

### Templates


#### stand alone

`````js
type a = #;
`````

#### in paren

`````js
type a = (#);
`````

#### double paren

`````js
type a = ((#));
`````

#### tuple

`````js
type a = [#];
`````

#### index

`````js
type a = [#][];
`````

#### mix

`````js
type a = [#][#];
`````

