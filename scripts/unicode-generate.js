'use strict';

// This generates lookup tables with a common lookup function aware of the encoding to minimize the
// number of comparisons required, especially for the common case. I'd rather not have a very slow
// runtime test.
//
// Note that this has a dependency on `unicode-10.0.0` if executed directly.
//
// `generate(opts)`, default-exported, generates a source from one or more lists of code points and
// associated exports.
//
// It accepts these named options:
//
// - `eval` - (optional) boolean, `true` if this should emit a JS body
// - `write` - promise-returning function called on each written string
// - `exports` - mapping of name + list of functions returning only *positive* code points
//
// To use this, you do something like this:
//
// ```js
// import {isIDContinue} from "./unicode-generated";
//
// if (isIDContinue(charCode)) {
//     doThings();
// }
// ```
//
// The codes are stored in a shared typed array as *n* packed sets of 2176 32-bit bit vectors.

// TODO:
// 1. Investigate code matching bugs

const UnicodeCodeCount = 0x110000; /* codes */
const VectorSize = Uint32Array.BYTES_PER_ELEMENT * 8;
const VectorMask = VectorSize - 1;
const VectorBitCount = 32 - Math.clz32(VectorMask);
const VectorByteSize = UnicodeCodeCount / VectorSize;

// A basic, primitive run-length + dictionary compression algorithm, to trim the generated code
// size by quite a bit.
//
// Format:
//
// - (-x) - Skip `x` iterations. (Used to optimize repeated zeroes)
// - (0, x) - Define `x` as the `ref`th value if `>= 10`, and emit 1 instance of it.
// - (Link, ref) - Emit 1 instance of the `ref`th value.
// - (Many, x, len) - Define `x` as the `ref`th value if `>= 10`, and emit it `len` times.
// - (Link | Many, ref, len) - Emit the `ref`th value `len` times.

const DataInst = Object.freeze({
  Empty: 0x0,
  Many: 0x1,
  Link: 0x2
});
exports.DataInst = DataInst;

// Lazily consume codes, so I can send them without using up tons of memory.
exports.compressorCreate = compressorCreate;
function compressorCreate() {
  return {
    result: [],
    dictLocs: Object.create(null),
    dictIn: Object.create(null),
    dict: [],
    count: 0,
    prev: 0,
    mask: DataInst.Empty,
    size: 0
  };
}

exports.compressorSend = compressorSend;
function compressorSend(state, code) {
  state.size++;

  if (state.count === 0) {
    state.prev = code;
    state.count++;
    return;
  }

  if (state.prev === code) {
    state.mask |= DataInst.Many;
    state.count++;
    return;
  }

  if (state.prev === 0) {
    state.result.push(-state.count);
  } else {
    state.result.push(state.mask);

    if (state.mask & DataInst.Link) {
      state.result.push(state.dictIn[state.prev]);
    } else {
      if (state.prev >= 10) state.dictLocs[state.prev] = state.result.length;
      state.result.push(state.prev);
    }

    if (state.mask & DataInst.Many) state.result.push(state.count);
  }

  state.prev = code;
  state.mask = DataInst.Empty;
  state.count = 1;
  const loc = state.dictLocs[code];

  if (loc == null) return;
  state.mask |= DataInst.Link;

  // Upgrade the first use to a ref if necessary
  if (loc !== 0) {
    state.dictLocs[code] = 0;
    state.result[loc - 1] |= DataInst.Link;
    state.result[loc] = state.dict.length;
    state.dictIn[code] = state.dict.length;
    state.dict.push(code);
  }
}

exports.compressorEnd = compressorEnd;
function compressorEnd(state) {
  if (state.prev === 0) {
    state.result.push(-state.count);
  } else {
    state.result.push(state.mask);

    if (state.mask & DataInst.Link) {
      state.result.push(state.dictIn[state.prev]);
    } else {
      state.result.push(state.prev);
    }

    if (state.mask & DataInst.Many) state.result.push(state.count);
  }
}

// Exported for testing
exports.decompress = decompress;
function decompress(compressed) {
  return new Function(`return ${makeDecompress(compressed)}`)();
}

const makeDecompress = (compressed) => `((compressed, dict) => {
    const result = new Uint32Array(${compressed.size})
    let i = 0, j = 0
    while (i < ${compressed.result.length}) {
        const inst = compressed[i++]
        if (inst < 0) {
            j -= inst
        } else {
            let code = compressed[i++]
            if (inst & ${DataInst.Link}) code = dict[code]
            if (inst & ${DataInst.Many}) {
                result.fill(code, j, j += compressed[i++])
            } else {
                result[j++] = code
            }
        }
    }
    return result
})(
    [${compressed.result}],
    [${compressed.dict}]
)`;

exports.generate = generate;
async function generate(opts) {
  await opts.write(`/* tslint:disable */
"use strict";
/*
 * Do not edit! This is an autogenerated file. If you wish to edit the source, please consult
 * scripts/unicode-generate.js
 */
`);

  const exportKeys = Object.keys(opts.exports);
  const compress = compressorCreate();

  for (const [index, exported] of exportKeys.entries()) {
    const codes = new Uint32Array(VectorByteSize);
    const items = opts.exports[exported];

    for (const list of items) {
      for (const item of list) {
        codes[item >>> VectorBitCount] |= 1 << (item & VectorMask);
      }
    }

    for (const code of codes) {
      compressorSend(compress, code);
    }

    await opts.write(`
function ${exported}(code${opts.eval ? '' : ':number'}) {
    const bit = code & ${VectorMask}
    return (_[(code >>> ${VectorBitCount}) + ${index * VectorByteSize}] >>> bit & 1) !== 0
}
`);
  }

  compressorEnd(compress);

  await opts.write(`
const _ = ${makeDecompress(compress)}
${opts.eval ? 'return' : 'export'} {${Object.keys(opts.exports)}};
`);
}

// Edit these here to change the options when run directly.

if (require.main === module) {
  const path = require('path');
  const load = (name) => {
    const mod = require.resolve(`unicode-13.0.0/${name}/code-points`);
    const list = require(mod);

    // Keep this out of persistent memory
    delete require.cache[mod];
    return list;
  };

  const stream = require('fs').createWriteStream(path.resolve(__dirname, '../src/unicode-generated.ts'));

  generate({
    write: (str) =>
      new Promise((resolve, reject) => {
        stream.write(str, (err) => (err != null ? reject(err) : resolve()));
      }),
    exports: {
      isIDContinue: [load('Binary_Property/ID_Continue')],
      isIDStart: [load('Binary_Property/ID_Start')],
      isLineTerminator: [
        load('Line_Break/Carriage_Return'),
        load('Line_Break/Line_Feed'),
        load('General_Category/Paragraph_Separator'),
        load('General_Category/Line_Separator')
      ],
      isWhitespaceOrLineTerminator: [
        load('Line_Break/Carriage_Return'),
        load('Line_Break/Line_Feed'),
        load('Line_Break/ZWJ'),
        load('Line_Break/ZWSpace'),
        load('Binary_Property/White_Space'),
        load('General_Category/Paragraph_Separator'),
        load('General_Category/Line_Separator'),
        load('General_Category/Separator'),
        [45, 47, 60]
      ]
    }
  })
    // Node only started exiting on collected rejections in v8
    .catch((e) =>
      process.nextTick(() => {
        throw e;
      })
    );
}
